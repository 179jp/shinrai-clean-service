<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>カビ文字デモ（小さめ＆色バリエーション）</title>
    <style>
      body {
        margin: 0;
        background: #222;
        overflow: hidden;
      }
      canvas {
        display: block;
        background: #ddd;
      }
    </style>
  </head>
  <body>
    <canvas id="moldCanvas"></canvas>

    <script>
      const canvas = document.getElementById("moldCanvas");
      const ctx = canvas.getContext("2d");

      // タイル設定
      const tileSize = 60; // 白タイルの一辺
      const groutSize = 4; // 目地幅
      const tileColor = "#fdfdfd";
      const groutColor = "#c0c0c0";

      // カビ（文字）設定
      const spawnProbability = 0.02; // 毎フレーム 新しいカビ簇が生える確率
      const molds = [];

      // 画面サイズに追従
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawTiles(); // 背景再描画
        molds.length = 0; // シンプルにリセット
        spawnInitialMold();
      }
      window.addEventListener("resize", resizeCanvas);

      function drawTiles() {
        const W = canvas.width;
        const H = canvas.height;

        // 全面を目地色で塗る
        ctx.fillStyle = groutColor;
        ctx.fillRect(0, 0, W, H);

        // 白タイル
        for (let y = 0; y < H; y += tileSize + groutSize) {
          for (let x = 0; x < W; x += tileSize + groutSize) {
            ctx.fillStyle = tileColor;
            ctx.fillRect(
              x + groutSize / 2,
              y + groutSize / 2,
              tileSize,
              tileSize
            );
          }
        }
      }

      class MoldCluster {
        constructor(x, y) {
          this.originX = x;
          this.originY = y;

          this.maxRadius = 40 + Math.random() * 80;
          this.alive = true;

          // クラスターごとに基準の色相を決める（緑〜黄緑〜青緑あたり）
          this.hueBase = 100 + Math.random() * 50; // 100〜150
          this.satBase = 35 + Math.random() * 20; // 彩度 35〜55
          this.lightBase = 60 + Math.random() * 10; // 明度 60〜70

          this.glyphs = []; // {x, y, size, angle, intensity, hue, sat, light, char}
          this.glyphSet = new Set();

          // 最初の「カ」「ビ」ペア
          this.addKaBiPair(x, y);
        }

        key(x, y, char) {
          return `${Math.round(x)}_${Math.round(y)}_${char}`;
        }

        addGlyph(x, y, char) {
          const k = this.key(x, y, char);
          if (this.glyphSet.has(k)) return;
          this.glyphSet.add(k);

          const size = 8 + Math.random() * 4; // 小さめの初期サイズ（8〜12px）
          const angle = (Math.random() - 0.5) * 1.6; // -0.8〜0.8rad くらいで、だいぶバラつかせる
          const intensity = 0.25 + Math.random() * 0.25; // 初期濃さ

          // 色バリエーション（クラスター基準から少し揺らす）
          const hue = this.hueBase + (Math.random() - 0.5) * 14; // ±7°
          const sat = this.satBase + (Math.random() - 0.5) * 10; // ±5
          const light = this.lightBase + (Math.random() - 0.5) * 8; // ±4

          this.glyphs.push({
            x,
            y,
            size,
            angle,
            intensity,
            hue,
            sat,
            light,
            char,
          });
        }

        addKaBiPair(x, y) {
          // 基準位置に「カ」
          this.addGlyph(x, y, "カ");

          // 「カ」から少し離れた位置に「ビ」
          const dist = 10 + Math.random() * 18; // 10〜28px くらい離す
          const theta = Math.random() * Math.PI * 2;
          const bx = x + Math.cos(theta) * dist;
          const by = y + Math.sin(theta) * dist;
          this.addGlyph(bx, by, "ビ");
        }

        update() {
          if (!this.alive) return;

          const maxNewPerFrame = 3;
          let added = 0;

          for (const g of this.glyphs) {
            // 文字サイズを少しずつ大きく（上限も少し小さめ）
            if (g.size < 20) {
              g.size += 0.025;
            }

            // 濃さも少しずつ強く
            if (g.intensity < 1.0) {
              g.intensity += 0.002;
            }

            // 濃くなるに従って、ほんの少し暗く・鮮やかにしていく
            g.light = Math.max(30, g.light - 0.0015);
            g.sat = Math.min(65, g.sat + 0.001);

            // たまに周囲に新しい「カビ」ペアを増殖
            if (Math.random() < 0.02 && added < maxNewPerFrame) {
              const dirs = [
                [1, 0],
                [-1, 0],
                [0, 1],
                [0, -1],
                [1, 1],
                [1, -1],
                [-1, 1],
                [-1, -1],
              ];
              const [dx, dy] = dirs[Math.floor(Math.random() * dirs.length)];

              const distUnit = 14;
              const nx = g.x + dx * distUnit;
              const ny = g.y + dy * distUnit;

              const distFromOrigin = Math.hypot(
                nx - this.originX,
                ny - this.originY
              );
              if (distFromOrigin <= this.maxRadius) {
                this.addKaBiPair(nx, ny);
                added++;
              }
            }
          }

          // ある程度増えたら「成長終了」
          if (this.glyphs.length > this.maxRadius * 1.2) {
            this.alive = false;
          }
        }

        draw(ctx) {
          for (const g of this.glyphs) {
            ctx.save();
            ctx.translate(g.x, g.y);
            ctx.rotate(g.angle);

            ctx.font = `bold ${g.size}px "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // 線と塗りに少し差をつけてコミカルに
            const strokeLight = Math.max(0, g.light - 20);
            const strokeAlpha = g.intensity * 0.6;
            const fillAlpha = g.intensity;

            ctx.lineWidth = 1;
            ctx.strokeStyle = `hsla(${g.hue}, ${g.sat}%, ${strokeLight}%, ${strokeAlpha})`;
            ctx.fillStyle = `hsla(${g.hue}, ${g.sat}%, ${g.light}%, ${fillAlpha})`;

            ctx.strokeText(g.char, 0, 0);
            ctx.fillText(g.char, 0, 0);

            ctx.restore();
          }
        }
      }

      function spawnMoldAlongGrout() {
        const W = canvas.width;
        const H = canvas.height;

        const vertical = Math.random() < 0.5;

        if (vertical) {
          const colCount = Math.ceil(W / (tileSize + groutSize));
          const colIndex = Math.floor(Math.random() * colCount);
          const xBase = colIndex * (tileSize + groutSize);
          const x = Math.round(xBase + groutSize / 2);

          const y = Math.round(Math.random() * H);
          molds.push(new MoldCluster(x, y));
        } else {
          const rowCount = Math.ceil(H / (tileSize + groutSize));
          const rowIndex = Math.floor(Math.random() * rowCount);
          const yBase = rowIndex * (tileSize + groutSize);
          const y = Math.round(yBase + groutSize / 2);

          const x = Math.round(Math.random() * W);
          molds.push(new MoldCluster(x, y));
        }
      }

      function spawnInitialMold() {
        for (let i = 0; i < 10; i++) {
          spawnMoldAlongGrout();
        }
      }

      function update() {
        // 新しいカビ簇をときどき生成
        if (Math.random() < spawnProbability) {
          spawnMoldAlongGrout();
        }

        for (const m of molds) {
          m.update();
        }

        // メモリ対策（死んだ簇をたまに間引き）
        if (molds.length > 1000) {
          for (let i = molds.length - 1; i >= 0; i--) {
            if (!molds[i].alive) {
              molds.splice(i, 1);
            }
          }
        }
      }

      function draw() {
        drawTiles();
        for (const m of molds) {
          m.draw(ctx);
        }
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      // 初期化
      resizeCanvas();
      spawnInitialMold();
      loop();
    </script>
  </body>
</html>
